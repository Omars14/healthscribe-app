{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Omar/Desktop/AI%20website%20Latest/dashboard-next/src/lib/admin-service.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport { AdminUser, UserFilters, UserStats, BulkUpdatePayload, BulkUpdateResult, AdminApiError } from '@/types/admin';\nimport { UserRole } from '@/types/review';\n\n/**\n * Create an admin client with service role key for privileged operations\n * This should only be used in server-side code (API routes, server actions)\n */\nexport function createAdminClient() {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    throw new Error('Missing Supabase environment variables for admin client');\n  }\n\n  return createClient(supabaseUrl, supabaseServiceKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false\n    }\n  });\n}\n\n/**\n * Process sorted users and return formatted result\n */\nasync function processSortedUsers(\n  adminClient: any,\n  sortedUserIds: string[],\n  transcriptionCounts: { [key: string]: number },\n  offset: number,\n  pageSize: number\n): Promise<{ users: AdminUser[]; total: number }> {\n  const paginatedUserIds = sortedUserIds.slice(offset, offset + pageSize);\n\n  const { data: users, error: fetchError } = await adminClient\n    .from('user_profiles')\n    .select(`\n      id,\n      email,\n      full_name,\n      role,\n      assigned_editor_id,\n      is_active,\n      last_active,\n      created_at,\n      updated_at\n    `)\n    .in('id', paginatedUserIds);\n\n  if (fetchError) {\n    console.error('Error fetching sorted users:', fetchError);\n    throw fetchError;\n  }\n\n  // Get editor information for users who have assigned editors\n  const usersWithEditors = (users || []).filter(user => user.assigned_editor_id);\n  let editorMap: { [key: string]: { full_name: string; email: string } } = {};\n\n  if (usersWithEditors.length > 0) {\n    const editorIds = usersWithEditors.map(user => user.assigned_editor_id);\n    const { data: editors, error: editorError } = await adminClient\n      .from('user_profiles')\n      .select('id, full_name, email')\n      .in('id', editorIds);\n\n    if (!editorError && editors) {\n      editors.forEach(editor => {\n        editorMap[editor.id] = { full_name: editor.full_name, email: editor.email };\n      });\n    }\n  }\n\n  // Process users with transcription counts and editor info\n  const processedUsers = (users || []).map(user => {\n    const editor = editorMap[user.assigned_editor_id || ''];\n    return {\n      ...user,\n      transcription_count: transcriptionCounts[user.id] || 0,\n      review_count: 0,\n      assigned_editor_name: editor?.full_name || editor?.email || null,\n      last_sign_in_at: null,\n      email_confirmed_at: null\n    };\n  });\n\n  return {\n    users: processedUsers,\n    total: sortedUserIds.length\n  };\n}\n\n/**\n * Sort users by activity (transcription count) with proper pagination\n */\nasync function sortByActivity(\n  adminClient: any,\n  filters: UserFilters,\n  page: number,\n  pageSize: number\n): Promise<{ users: AdminUser[]; total: number }> {\n  const {\n    search = null,\n    role = null,\n    isActive = null,\n    sortDirection = 'desc' // Default to descending for activity\n  } = filters;\n\n\n  const offset = (page - 1) * pageSize;\n\n  try {\n    // First, get all user IDs that match the filters\n    let userQuery = adminClient\n      .from('user_profiles')\n      .select('id');\n\n    // Apply filters\n    if (role && role !== '') {\n      userQuery = userQuery.eq('role', role);\n    }\n    if (isActive !== null && isActive !== '') {\n      userQuery = userQuery.eq('is_active', isActive);\n    }\n    if (search) {\n      userQuery = userQuery.or(`email.ilike.%${search}%,full_name.ilike.%${search}%`);\n    }\n\n    const { data: filteredUsers, error: userError } = await userQuery;\n    if (userError) throw userError;\n\n    const userIds = (filteredUsers || []).map(u => u.id);\n\n    if (userIds.length === 0) {\n      return { users: [], total: 0 };\n    }\n\n    // Get transcription counts for all filtered users\n    const { data: transcriptionData, error: transcriptionError } = await adminClient\n      .from('transcriptions')\n      .select('user_id')\n      .in('user_id', userIds)\n      .eq('status', 'completed');\n\n    if (transcriptionError) {\n      console.error('Error fetching transcriptions for sorting:', transcriptionError);\n      // Fallback: assume all users have 0 transcriptions\n      const transcriptionCounts: { [key: string]: number } = {};\n      userIds.forEach(id => transcriptionCounts[id] = 0);\n\n      const sortedUserIds = userIds.sort((a, b) => {\n        return sortDirection === 'asc' ? 0 - 0 : 0 - 0; // All equal\n      });\n\n      return await processSortedUsers(adminClient, sortedUserIds, transcriptionCounts, offset, pageSize);\n    }\n\n    // Count transcriptions per user\n    const transcriptionCounts: { [key: string]: number } = {};\n    (transcriptionData || []).forEach((t: any) => {\n      transcriptionCounts[t.user_id] = (transcriptionCounts[t.user_id] || 0) + 1;\n    });\n\n    // Create a sorted list of user IDs by transcription count\n    const sortedUserIds = [...userIds].sort((a, b) => {\n      const aCount = transcriptionCounts[a] || 0;\n      const bCount = transcriptionCounts[b] || 0;\n      return sortDirection === 'asc' ? aCount - bCount : bCount - aCount;\n    });\n\n    return await processSortedUsers(adminClient, sortedUserIds, transcriptionCounts, offset, pageSize);\n  } catch (error) {\n    console.error('Error in sortByActivity:', error);\n    throw error;\n  }\n}\n\n/**\n * List all users with filters and pagination\n */\nexport async function listUsers(filters: UserFilters = {}): Promise<{ users: AdminUser[]; total: number }> {\n  const adminClient = createAdminClient();\n  \n  const {\n    search = null,\n    role = null,\n    isActive = null,\n    page = 1,\n    pageSize = 50,\n    sortField = null,\n    sortDirection = 'asc'\n  } = filters;\n\n  // Ensure page is at least 1 to prevent negative offset\n  const safePage = Math.max(1, page);\n  const offset = (safePage - 1) * pageSize;\n\n  try {\n    // Get user profiles with pagination (without problematic joins)\n    let query = adminClient\n      .from('user_profiles')\n      .select(`\n        id,\n        email,\n        full_name,\n        role,\n        assigned_editor_id,\n        is_active,\n        last_active,\n        created_at,\n        updated_at\n      `);\n\n    // Apply filters first (before sorting)\n    if (role && role !== '') {\n      query = query.eq('role', role);\n    }\n    if (isActive !== null && isActive !== '') {\n      query = query.eq('is_active', isActive);\n    }\n    if (search) {\n      query = query.or(`email.ilike.%${search}%,full_name.ilike.%${search}%`);\n    }\n\n    // Apply sorting (before pagination for database-level sorting)\n    if (sortField) {\n      let ascending = sortDirection === 'asc';\n\n      switch (sortField) {\n        case 'name':\n          query = query.order('full_name', { ascending, nullsFirst: false });\n          break;\n        case 'role':\n          query = query.order('role', { ascending });\n          break;\n        case 'status':\n          query = query.order('is_active', { ascending });\n          break;\n        case 'created_at':\n          query = query.order('created_at', { ascending });\n          break;\n        case 'activity':\n          // For activity sorting, we need a more complex approach\n          // We'll use a subquery to get transcription counts and sort by them\n          return await sortByActivity(adminClient, filters, safePage, pageSize);\n        default:\n          query = query.order('created_at', { ascending: false });\n      }\n    } else {\n      // Default sorting by created_at desc\n      query = query.order('created_at', { ascending: false });\n    }\n\n    // Apply pagination after sorting\n    query = query.range(offset, offset + pageSize - 1);\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('Error listing users:', error);\n      throw new Error(error.message);\n    }\n\n    // Use a more efficient approach with a single query that includes transcription counts\n    // First, get all users\n    const userIds = (data || []).map(user => user.id);\n\n    // Get transcription counts\n    let transcriptionCounts: { [key: string]: number } = {};\n\n    if (userIds.length > 0) {\n      const { data: transcriptions, error: transcriptionError } = await adminClient\n        .from('transcriptions')\n        .select('user_id')\n        .in('user_id', userIds)\n        .eq('status', 'completed');\n\n      if (!transcriptionError && transcriptions) {\n        transcriptions.forEach((t: any) => {\n          transcriptionCounts[t.user_id] = (transcriptionCounts[t.user_id] || 0) + 1;\n        });\n      }\n    }\n\n    // Get editor information for users who have assigned editors\n    const usersWithEditors = (data || []).filter(user => user.assigned_editor_id);\n    let editorMap: { [key: string]: { full_name: string; email: string } } = {};\n\n    if (usersWithEditors.length > 0) {\n      const editorIds = usersWithEditors.map(user => user.assigned_editor_id);\n      const { data: editors, error: editorError } = await adminClient\n        .from('user_profiles')\n        .select('id, full_name, email')\n        .in('id', editorIds);\n\n      if (!editorError && editors) {\n        editors.forEach(editor => {\n          editorMap[editor.id] = { full_name: editor.full_name, email: editor.email };\n        });\n      }\n    }\n\n    // Process the data to include transcription counts and editor names\n    const processedUsers = (data || []).map(user => {\n      const editor = editorMap[user.assigned_editor_id || ''];\n      return {\n        ...user,\n        transcription_count: transcriptionCounts[user.id] || 0,\n        review_count: 0, // TODO: Calculate review count if needed\n        assigned_editor_name: editor?.full_name || editor?.email || null,\n        last_sign_in_at: null, // Not available in current schema\n        email_confirmed_at: null // Not available in current schema\n      };\n    });\n\n\n    // Get total count for pagination (without pagination)\n    let countQuery = adminClient\n      .from('user_profiles')\n      .select('*', { count: 'exact', head: true });\n\n    if (role && role !== '') {\n      countQuery = countQuery.eq('role', role);\n    }\n    if (isActive !== null && isActive !== '') {\n      countQuery = countQuery.eq('is_active', isActive);\n    }\n    if (search) {\n      countQuery = countQuery.or(`email.ilike.%${search}%,full_name.ilike.%${search}%`);\n    }\n\n    const { count } = await countQuery;\n\n    return {\n      users: processedUsers,\n      total: count || 0\n    };\n  } catch (error) {\n    console.error('Failed to list users:', error);\n    throw error;\n  }\n}\n\n/**\n * Update a user's role\n */\nexport async function updateUserRole(userId: string, newRole: UserRole): Promise<void> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { error } = await adminClient.rpc('admin_update_user_role', {\n      user_id: userId,\n      new_role: newRole\n    });\n\n    if (error) {\n      console.error('Error updating user role:', error);\n      throw new Error(error.message);\n    }\n  } catch (error) {\n    console.error('Failed to update user role:', error);\n    throw error;\n  }\n}\n\n/**\n * Assign an editor to a transcriptionist\n */\nexport async function assignEditor(transcriptionistId: string, editorId: string | null): Promise<void> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { error } = await adminClient.rpc('admin_assign_editor', {\n      transcriptionist_id: transcriptionistId,\n      editor_id: editorId\n    });\n\n    if (error) {\n      console.error('Error assigning editor:', error);\n      throw new Error(error.message);\n    }\n  } catch (error) {\n    console.error('Failed to assign editor:', error);\n    throw error;\n  }\n}\n\n/**\n * Bulk update multiple users\n */\nexport async function bulkUpdateUsers(payload: BulkUpdatePayload): Promise<BulkUpdateResult> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { data, error } = await adminClient.rpc('admin_bulk_update_users', {\n      user_ids: payload.userIds,\n      update_role: payload.role || null,\n      update_editor_id: payload.editorId !== undefined ? payload.editorId : null,\n      update_is_active: payload.isActive !== undefined ? payload.isActive : null\n    });\n\n    if (error) {\n      console.error('Error bulk updating users:', error);\n      throw new Error(error.message);\n    }\n\n    return data?.[0] || { updated_count: 0, error_count: 0 };\n  } catch (error) {\n    console.error('Failed to bulk update users:', error);\n    throw error;\n  }\n}\n\n/**\n * Get user statistics\n */\nexport async function getUserStats(): Promise<UserStats> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { data, error } = await adminClient.rpc('admin_get_user_stats');\n\n    if (error) {\n      console.error('Error getting user stats:', error);\n      throw new Error(error.message);\n    }\n\n    return data?.[0] || {\n      total_users: 0,\n      admins_count: 0,\n      editors_count: 0,\n      transcriptionists_count: 0,\n      active_users: 0,\n      inactive_users: 0,\n      users_last_30_days: 0\n    };\n  } catch (error) {\n    console.error('Failed to get user stats:', error);\n    throw error;\n  }\n}\n\n/**\n * Deactivate a user (soft delete)\n */\nexport async function deactivateUser(userId: string): Promise<void> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { error } = await adminClient.rpc('admin_deactivate_user', {\n      user_id: userId\n    });\n\n    if (error) {\n      console.error('Error deactivating user:', error);\n      throw new Error(error.message);\n    }\n  } catch (error) {\n    console.error('Failed to deactivate user:', error);\n    throw error;\n  }\n}\n\n/**\n * Get all editors for assignment dropdown\n */\nexport async function getEditors(): Promise<{ id: string; name: string; email: string }[]> {\n  const adminClient = createAdminClient();\n\n  try {\n    const { data, error } = await adminClient\n      .from('user_profiles')\n      .select('id, email, full_name')\n      .eq('role', 'editor')\n      .eq('is_active', true)\n      .order('full_name');\n\n    if (error) {\n      console.error('Error fetching editors:', error);\n      throw new Error(error.message);\n    }\n\n    return (data || []).map(editor => ({\n      id: editor.id,\n      name: editor.full_name || editor.email,\n      email: editor.email\n    }));\n  } catch (error) {\n    console.error('Failed to fetch editors:', error);\n    throw error;\n  }\n}\n\n/**\n * Get upload statistics for all users\n */\nexport async function getUserUploadStats(timeRange?: '7d' | '30d' | '90d' | 'all'): Promise<{\n  userId: string;\n  email: string;\n  fullName: string;\n  role: string;\n  totalUploads: number;\n  totalFileSize: number;\n  totalFileSizeMB: number;\n  lastUpload: string | null;\n  uploadsThisPeriod: number;\n  fileSizeThisPeriod: number;\n  fileSizeThisPeriodMB: number;\n}[]> {\n  const adminClient = createAdminClient();\n\n  try {\n    // Calculate date filter based on time range\n    let dateFilter = '';\n    if (timeRange && timeRange !== 'all') {\n      const days = timeRange === '7d' ? 7 : timeRange === '30d' ? 30 : 90;\n      const date = new Date();\n      date.setDate(date.getDate() - days);\n      dateFilter = date.toISOString();\n    }\n\n    // Get all transcriptions first\n    let transcriptionQuery = adminClient\n      .from('transcriptions')\n      .select('id, user_id, file_size, created_at, status')\n      .eq('status', 'completed');\n\n    if (dateFilter) {\n      transcriptionQuery = transcriptionQuery.gte('created_at', dateFilter);\n    }\n\n    const { data: transcriptions, error } = await transcriptionQuery;\n\n    if (error) {\n      console.error('Error fetching upload stats:', error);\n      throw new Error(error.message);\n    }\n\n    // Get unique user IDs\n    const userIds = [...new Set((transcriptions || []).map(t => t.user_id))];\n\n    // Fetch user information\n    const { data: users, error: userError } = await adminClient\n      .from('user_profiles')\n      .select('id, email, full_name, role')\n      .in('id', userIds);\n\n    if (userError) {\n      console.error('Error fetching users for upload stats:', userError);\n      throw new Error(userError.message);\n    }\n\n    // Create user map\n    const userMap = new Map();\n    (users || []).forEach(user => {\n      userMap.set(user.id, user);\n    });\n\n    // Group by user and calculate stats\n    const userStats = new Map();\n\n    (transcriptions || []).forEach((transcription: any) => {\n      const userId = transcription.user_id;\n      const user = userMap.get(userId);\n\n      if (user && !userStats.has(userId)) {\n        userStats.set(userId, {\n          userId,\n          email: user.email,\n          fullName: user.full_name || user.email,\n          role: user.role,\n          totalUploads: 0,\n          totalFileSize: 0,\n          totalFileSizeMB: 0,\n          totalAudioMinutes: 0,\n          lastUpload: null,\n          uploadsThisPeriod: 0,\n          fileSizeThisPeriod: 0,\n          fileSizeThisPeriodMB: 0,\n          audioMinutesThisPeriod: 0\n        });\n      }\n\n      const stats = userStats.get(userId);\n\n      // Calculate estimated audio duration (rough estimate: ~128kbps = ~1MB per 8 minutes)\n      const fileSizeMB = (transcription.file_size || 0) / (1024 * 1024);\n      const estimatedMinutes = Math.round(fileSizeMB * 8); // Rough estimate\n      const audioDurationSeconds = transcription.audio_duration_seconds || (estimatedMinutes * 60);\n\n      // Update totals\n      stats.totalUploads += 1;\n      stats.totalFileSize += transcription.file_size || 0;\n      stats.totalFileSizeMB = parseFloat((stats.totalFileSize / (1024 * 1024)).toFixed(2));\n      stats.totalAudioMinutes += Math.round(audioDurationSeconds / 60);\n\n      // Update last upload date\n      const uploadDate = new Date(transcription.created_at);\n      if (!stats.lastUpload || uploadDate > new Date(stats.lastUpload)) {\n        stats.lastUpload = transcription.created_at;\n      }\n\n      // Update period stats if we're filtering by time range\n      if (dateFilter) {\n        stats.uploadsThisPeriod += 1;\n        stats.fileSizeThisPeriod += transcription.file_size || 0;\n        stats.fileSizeThisPeriodMB = parseFloat((stats.fileSizeThisPeriod / (1024 * 1024)).toFixed(2));\n        stats.audioMinutesThisPeriod += Math.round(audioDurationSeconds / 60);\n      }\n    });\n\n    // If no date filter, get all-time stats for period fields too\n    if (!dateFilter) {\n      for (const stats of userStats.values()) {\n        stats.uploadsThisPeriod = stats.totalUploads;\n        stats.fileSizeThisPeriod = stats.totalFileSize;\n        stats.fileSizeThisPeriodMB = stats.totalFileSizeMB;\n        stats.audioMinutesThisPeriod = stats.totalAudioMinutes;\n      }\n    }\n\n    return Array.from(userStats.values()).sort((a, b) => b.totalUploads - a.totalUploads);\n  } catch (error) {\n    console.error('Failed to get user upload stats:', error);\n    throw error;\n  }\n}\n\n/**\n * Get overall upload statistics\n */\nexport async function getOverallUploadStats(): Promise<{\n  totalUploads: number;\n  totalUsers: number;\n  totalFileSize: number;\n  totalFileSizeGB: number;\n  averageUploadsPerUser: number;\n  averageFileSizeMB: number;\n  uploadsLast7Days: number;\n  uploadsLast30Days: number;\n  topUploader: {\n    email: string;\n    fullName: string;\n    uploads: number;\n  } | null;\n}> {\n  const adminClient = createAdminClient();\n\n  try {\n    // Get all completed transcriptions\n    const { data: allTranscriptions, error: allError } = await adminClient\n      .from('transcriptions')\n      .select('user_id, file_size, created_at')\n      .eq('status', 'completed');\n\n    if (allError) {\n      throw new Error(allError.message);\n    }\n\n    // Get transcriptions from last 7 days\n    const sevenDaysAgo = new Date();\n    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n    const { data: recentTranscriptions, error: recentError } = await adminClient\n      .from('transcriptions')\n      .select('id')\n      .eq('status', 'completed')\n      .gte('created_at', sevenDaysAgo.toISOString());\n\n    if (recentError) {\n      throw new Error(recentError.message);\n    }\n\n    // Get transcriptions from last 30 days\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n    const { data: monthTranscriptions, error: monthError } = await adminClient\n      .from('transcriptions')\n      .select('id')\n      .eq('status', 'completed')\n      .gte('created_at', thirtyDaysAgo.toISOString());\n\n    if (monthError) {\n      throw new Error(monthError.message);\n    }\n\n    const transcriptions = allTranscriptions || [];\n    const totalUploads = transcriptions.length;\n    const totalFileSize = transcriptions.reduce((sum, t) => sum + (t.file_size || 0), 0);\n    const totalFileSizeGB = parseFloat((totalFileSize / (1024 * 1024 * 1024)).toFixed(2));\n\n    // Calculate total audio minutes\n    const totalAudioMinutes = transcriptions.reduce((sum, t) => {\n      const fileSizeMB = (t.file_size || 0) / (1024 * 1024);\n      const estimatedMinutes = Math.round(fileSizeMB * 8); // Rough estimate\n      const audioDurationSeconds = t.audio_duration_seconds || (estimatedMinutes * 60);\n      return sum + Math.round(audioDurationSeconds / 60);\n    }, 0);\n\n    // Get unique users\n    const uniqueUsers = new Set(transcriptions.map(t => t.user_id));\n    const totalUsers = uniqueUsers.size;\n\n    // Calculate averages\n    const averageUploadsPerUser = totalUsers > 0 ? Math.round(totalUploads / totalUsers) : 0;\n    const averageFileSizeMB = totalUploads > 0 ? parseFloat((totalFileSize / (1024 * 1024) / totalUploads).toFixed(2)) : 0;\n    const averageAudioMinutesPerUser = totalUsers > 0 ? Math.round(totalAudioMinutes / totalUsers) : 0;\n\n    // Find top uploader\n    const userUploadCounts = new Map();\n    transcriptions.forEach(t => {\n      userUploadCounts.set(t.user_id, (userUploadCounts.get(t.user_id) || 0) + 1);\n    });\n\n    let topUploader = null;\n    if (userUploadCounts.size > 0) {\n      const topUserId = Array.from(userUploadCounts.entries())\n        .sort(([, a], [, b]) => b - a)[0][0];\n\n      const { data: userData } = await adminClient\n        .from('user_profiles')\n        .select('email, full_name')\n        .eq('id', topUserId)\n        .single();\n\n      if (userData) {\n        topUploader = {\n          email: userData.email,\n          fullName: userData.full_name || userData.email,\n          uploads: userUploadCounts.get(topUserId)\n        };\n      }\n    }\n\n    return {\n      totalUploads,\n      totalUsers,\n      totalFileSize,\n      totalFileSizeGB,\n      totalAudioMinutes,\n      averageUploadsPerUser,\n      averageFileSizeMB,\n      averageAudioMinutesPerUser,\n      uploadsLast7Days: (recentTranscriptions || []).length,\n      uploadsLast30Days: (monthTranscriptions || []).length,\n      topUploader\n    };\n  } catch (error) {\n    console.error('Failed to get overall upload stats:', error);\n    throw error;\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 683, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Omar/Desktop/AI%20website%20Latest/dashboard-next/src/app/api/admin/users/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { createClient } from '@supabase/supabase-js';\nimport { cookies } from 'next/headers';\nimport { createAdminClient, listUsers, getUserStats, getUserUploadStats, getOverallUploadStats } from '@/lib/admin-service';\nimport { UserFilters } from '@/types/admin';\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Check authentication\n    const cookieStore = await cookies();\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';\n    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';\n\n    if (!supabaseUrl || !supabaseAnonKey) {\n      return NextResponse.json({ error: 'Supabase configuration missing' }, { status: 500 });\n    }\n\n    // Try multiple ways to get the auth token\n    let fullAuthToken = null;\n\n    // Method 1: Try the main cookie\n    const mainToken = cookieStore.get('sb-yaznemrwbingjwqutbvb-auth-token')?.value;\n    if (mainToken && mainToken.length > 100) { // JWT tokens are typically long\n      fullAuthToken = mainToken;\n    }\n\n    // Method 2: Try to reconstruct from parts\n    if (!fullAuthToken) {\n      const authToken0 = cookieStore.get('sb-yaznemrwbingjwqutbvb-auth-token.0')?.value;\n      const authToken1 = cookieStore.get('sb-yaznemrwbingjwqutbvb-auth-token.1')?.value;\n\n      if (authToken0 && authToken1) {\n        fullAuthToken = `${authToken0}.${authToken1}`;\n      } else if (authToken0) {\n        fullAuthToken = authToken0;\n      }\n    }\n\n    // Method 3: Check Authorization header as fallback\n    if (!fullAuthToken) {\n      const authHeader = request.headers.get('authorization');\n      if (authHeader && authHeader.startsWith('Bearer ')) {\n        fullAuthToken = authHeader.substring(7);\n      }\n    }\n\n    if (!fullAuthToken) {\n      return NextResponse.json({\n        error: 'No auth token',\n        message: 'Please log in first at /login'\n      }, { status: 401 });\n    }\n\n    // Create a minimal client for auth verification\n    const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n      auth: {\n        persistSession: false,\n        autoRefreshToken: false\n      }\n    });\n\n    const { data: { user }, error } = await supabase.auth.getUser(fullAuthToken);\n\n    const debugInfo = {\n      hasToken: !!fullAuthToken,\n      tokenLength: fullAuthToken?.length,\n      hasError: !!error,\n      errorMessage: error?.message,\n      hasUser: !!user,\n      userId: user?.id\n    };\n\n    console.log('Server auth debug:', debugInfo);\n\n    // Also write to file for easier debugging\n    const fs = require('fs');\n    const logPath = './debug.log';\n    fs.appendFileSync(logPath, `${new Date().toISOString()}: Server auth debug: ${JSON.stringify(debugInfo)}\\n`);\n\n    if (error || !user) {\n      console.log('Authentication failed:', { error, hasUser: !!user });\n      fs.appendFileSync(logPath, `${new Date().toISOString()}: Authentication failed: ${JSON.stringify({ error, hasUser: !!user })}\\n`);\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Use admin client for database operations\n    const adminClient = createAdminClient();\n\n    // Check if user is admin\n    const { data: profile, error: profileError } = await adminClient\n      .from('user_profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    const adminCheckInfo = {\n      userId: user.id,\n      hasProfile: !!profile,\n      profileRole: profile?.role,\n      profileError: profileError?.message,\n      isAdmin: profile?.role === 'admin'\n    };\n\n    console.log('Admin role check:', adminCheckInfo);\n    fs.appendFileSync(logPath, `${new Date().toISOString()}: Admin role check: ${JSON.stringify(adminCheckInfo)}\\n`);\n\n    if (!profile || profile.role !== 'admin') {\n      console.log('Admin check failed');\n      fs.appendFileSync(logPath, `${new Date().toISOString()}: Admin check failed\\n`);\n      return NextResponse.json({ error: 'Forbidden: Admin access required' }, { status: 403 });\n    }\n\n    console.log('Authentication successful for admin user:', user.id);\n    fs.appendFileSync(logPath, `${new Date().toISOString()}: Authentication successful for admin user: ${user.id}\\n`);\n\n    // Parse query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const rawPage = parseInt(searchParams.get('page') || '1');\n    const rawPageSize = parseInt(searchParams.get('pageSize') || '50');\n\n    const filters: UserFilters = {\n      search: searchParams.get('search') || undefined,\n      role: searchParams.get('role') as any || undefined,\n      isActive: searchParams.get('isActive') === 'true' ? true : searchParams.get('isActive') === 'false' ? false : undefined,\n      page: Math.max(1, rawPage), // Ensure page is at least 1\n      pageSize: Math.max(1, rawPageSize), // Ensure pageSize is at least 1\n      sortField: searchParams.get('sortField') as any || undefined,\n      sortDirection: searchParams.get('sortDirection') as any || undefined\n    };\n\n\n    // Handle different types of requests\n    const requestType = searchParams.get('type');\n\n    if (requestType === 'upload-stats') {\n      // Get upload statistics\n      const timeRange = searchParams.get('timeRange') as '7d' | '30d' | '90d' | 'all';\n      const userStats = await getUserUploadStats(timeRange);\n      const overallStats = await getOverallUploadStats();\n\n      return NextResponse.json({\n        userStats,\n        overallStats\n      });\n    }\n\n    // Get users and stats\n    const [usersData, stats] = await Promise.all([\n      listUsers(filters),\n      searchParams.get('includeStats') === 'true' ? getUserStats() : null\n    ]);\n\n    return NextResponse.json({\n      ...usersData,\n      stats\n    });\n  } catch (error: any) {\n    console.error('Error in admin users API:', error);\n    return NextResponse.json(\n      { error: error.message || 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}